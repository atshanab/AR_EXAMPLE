<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Face Landmarks — Diagnostic</title>
<style>
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{position:fixed;inset:0}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
  #hud{position:absolute;top:8px;right:8px;background:rgba(0,0,0,.5);padding:6px 10px;border-radius:8px;font-size:12px;white-space:pre}
  #btn{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);padding:10px 14px;border-radius:999px;border:0;background:#fff;color:#111;font-weight:700}
  #err{position:absolute;bottom:60px;left:12px;right:12px;background:rgba(255,0,0,.15);border:1px solid rgba(255,0,0,.5);padding:8px;border-radius:8px;font-size:12px;display:none;white-space:pre-wrap}
</style>
</head>
<body>
<div id="wrap">
  <video id="v" playsinline autoplay muted></video>
  <canvas id="c"></canvas>
  <div id="hud">loading…</div>
  <button id="btn">Start Camera</button>
  <div id="err"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/vision_bundle_mediapipe.js" crossorigin="anonymous"></script>
<script>
(async () => {
  const v = document.getElementById('v');
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  const hud = document.getElementById('hud');
  const btn = document.getElementById('btn');
  const errBox = document.getElementById('err');

  let lm=null, stream=null, running=false, last=performance.now();

  function setErr(t){ console.error(t); errBox.textContent=t; errBox.style.display='block'; }
  function clearErr(){ errBox.style.display='none'; errBox.textContent=''; }
  function fit(){ c.width = v.videoWidth||c.clientWidth; c.height = v.videoHeight||c.clientHeight; }
  function ns(){ return window.vision || window; }

  async function loadModel(){
    try{
      const {FilesetResolver, FaceLandmarker} = ns();
      if (!FilesetResolver || !FaceLandmarker){ throw new Error('Vision bundle not available.'); }
      const files = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/wasm');
      lm = await FaceLandmarker.createFromOptions(files, {
        baseOptions:{ modelAssetPath:'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.10/models/face_landmarker.task' },
        numFaces:1, runningMode:'VIDEO'
      });
      hud.textContent = 'model ready';
    }catch(e){
      setErr('Model load error: ' + (e && e.message ? e.message : e));
      hud.textContent = 'model load error';
    }
  }

  async function cam(){
    try{
      stream = await navigator.mediaDevices.getUserMedia({audio:false, video:{facingMode:'user', width:{ideal:1280}, height:{ideal:720}}});
      v.srcObject = stream; await v.play().catch(()=>{});
      fit(); btn.style.display='none'; hud.textContent = 'camera ready';
      return true;
    }catch(e){
      setErr('Camera error: ' + (e && e.message ? e.message : e));
      btn.style.display='block'; hud.textContent = 'camera blocked';
      return false;
    }
  }

  function drawDots(pts){
    const W=c.width,H=c.height;
    ctx.fillStyle='rgba(0,255,0,0.9)';
    for (let i=0;i<pts.length;i++){
      const p=pts[i]; const x=(1-p.x)*W; const y=p.y*H;
      ctx.beginPath(); ctx.arc(x,y,2,0,6.283); ctx.fill();
    }
  }

  async function loop(){
    if (!running) return;
    if (v.readyState>=2 && lm){
      if (v.videoWidth!==c.width || v.videoHeight!==c.height) fit();
      ctx.clearRect(0,0,c.width,c.height);
      try{
        const t=performance.now();
        const r=lm.detectForVideo(v,t);
        if (r && r.faceLandmarks && r.faceLandmarks.length){
          drawDots(r.faceLandmarks[0]);
          hud.textContent='face tracked ✓';
        } else {
          hud.textContent='searching for face…';
        }
        const dt=t-last; last=t;
      }catch(e){
        setErr('detectForVideo error: ' + (e && e.message ? e.message : e));
      }
    }
    requestAnimationFrame(loop);
  }

  btn.addEventListener('click', async ()=>{
    clearErr();
    const ok = await cam();
    if (ok && !lm){ await loadModel(); }
    running=true; loop();
  });

  await loadModel();
  const ok = await cam();
  running=true; loop();
  if (!ok){ btn.style.display='block'; }
})();
</script>
</body>
</html>
